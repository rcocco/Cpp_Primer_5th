## 练习14.1
> 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？

重载的运算符或者是类的成员，或者至少含有一个类类型的参数。  
重载的运算符不保证操作数的求值顺序，逻辑与和逻辑或等操作不再具有短路求值特性，两个操作数都会求值，且求值顺序是未定义的。  
重载的运算符和内置运算符的优先级、结合性、操作数的数目相同。  

## [练习14.2](ex14_02)
> 为 Sales_data 编写重载的输入、输出、加法和复合赋值运算符。

## 练习14.3
> string 和 vector 都定义了重载的`==`以比较各自的对象，假设 svec1 和 svec2 是存放 string 的 vector，确定在下面的表达式中分别使用了哪个版本的`==`？
```cpp
(a) "cobble" == "stone"  (b) svec1[0] == svec2[0]
(c) svec1 == svec2       (d) svec1[0] == "stone"
``` 

(a) 内置的`char*`版本。  
(b) string版本   
(c) vector版本  
(d) string版本，字面值常量被转换为`const string &`。  

## 练习14.4
> 如何确定下列运算符是否应该是类的成员？
```cpp
(a) % (b) %= (c) ++ (d) -> (e) << (f) && (g) == (h) ()
```
(a) 算术运算符具有对称性，一般不是成员。  
(b) 复合赋值运算符一般是成员。  
(c) 递增运算符会改变对象的状态，一般是成员。  
(d) 箭头运算符必须是成员。  
(e) 算术运算符，具有对称性，一般不是成员。当作为输出运算符时，只有不是成员才能让左侧运算对象是`IO`流。  
(f) 逻辑与具有对称性，一般不是成员。  
(g) 相等性运算符具有对称性，一般不是成员。  
(h) 调用运算符必须是成员。  

## [练习14.5](ex14_05)
> 在 7.5.1 节中的练习 7.40 （第 261 页）中，编写了下列类中某一个的框架，请问在这个类中应该定义重载的运算符吗？如果是，请写出来。
```cpp
(a) Book      (b) Date      (c) Employee
(d) Vehicle  (e) Object    (f) Tree
``` 	
以`Book`为例，应该定义重载的输入和输出运算符。  

## [练习14.6](ex14_06)
> 为你的 Sales_data 类定义输出运算符。

## [练习14.7](ex14_07)
> 你在 13.5 节的练习（第 470 页）中曾经编写了一个String类，为它定义一个输出运算符。

## [练习14.8](ex14_08)
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，为它定义一个输出运算符。

## [练习14.9](ex14_09)
> 为你的 Sales_data 类定义输入运算符。

## 练习14.10
> 对于 Sales_data 的输入运算符来说如果给定了下面的输入将发生什么情况？
```cpp
(a) 0-201-99999-9 10 24.95
(b) 10 24.95 0-210-99999-9
```
(a) `bookNo`为`0-201-99999-9`，`units_sold`为`10`，`price`为`24.95`，`revenue`为`249.5`。  
(b) `bookNo`为`10`，`units_sold`为`24`，`price`为`0.95`，`revenue`为`22.8`。在`cin >> units_sold`时，由于`units_sold`是一个无符号整型，`cin`在遇到字符`.`时就停止，并将`24`存入`units_sold`。此时`.95`仍然留在输入流中等待读取，之后读取的是`double`类型的`price`，`.95`被读入。    

## 练习14.11
> 下面的 Sales_data 输入运算符存在错误吗？如果有，请指出来。对于这个输入运算符如果仍然给定上个练习的输入将会发生什么情况？
```cpp
istream& operator>>(istream& in, Sales_data& s)
{
	double price;
	in >> s.bookNo >> s.units_sold >> price;
	s.revence = s.units_sold >> price;
	return in;
}
```
存在错误，在使用读取的数据前，没有检查输入是否出错。  
对于上个练习的输入仍然和上一题的结果完全一样。  
但对于`0-201-99999-9 10 as`这种输入，它的`price`没有成功读取，这使得`bookNo`、`units_sold`与错误的数据匹配在了一起。  

## [练习14.12](ex14_12)
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，为它定义一个输入运算符并确保该运算符可以处理输入错误。

## 练习14.13
> 你认为 Sales_data 类还应该支持哪些其他算术运算符（参见表 4.1，第 124 页）？如果有的话，请给出它们的定义。

对于`Sales_data`类，仅定义加法算术运算符来将两个数据合并已经足够。  

## 练习14.14
> 你觉得为什么调用 operator+= 来定义 operator+ 比其他方法更有效？

`operator+`中将临时对象加上右侧运算对象的代码，和`operator+=`中的代码完全相同。从性能上而言没有太大区别，但从可读性和代码复用的角度看调用`operator+=`更好，将来如果要改变加法的意义，只需改变一处代码。  

## 练习14.15
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，你认为它应该含有其他算术运算符吗？如果是，请实现它们；如果不是，解释原因。

`Book`含义是一本特定的书的信息，包括书名、ISBN号、价格、作者、出版商，对于它而言算术运算符没有逻辑上的意义，不能对两本书进行加减乘除求余，因此不应该含有算术运算符。  

## [练习14.16](ex14_16)
> 为你的 StrBlob 类（参见 12.1.1 节，第 405 页）、StrBlobPtr 类（参见 12.1.6 节，第 421 页）、StrVec 类（参见 13.5 节，第 465 页）和 String 类（参见 13.5 节，第 470 页）分别定义相等运算符和不相等运算符。

## [练习14.17](ex14_17)
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，你认为它应该含有相等运算符吗？如果是，请实现它；如果不是，解释原因。

应该有相等运算符，以比较两本书是否是指同一本。  

## [练习14.18](ex14_18)
> 为你的 StrBlob 类、StrBlobPtr 类、StrVec 类和 String 类定义关系运算符。

## 练习14.19
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，你认为它应该含有关系运算符吗？如果是，请实现它；如果不是，解释原因。

不应该有关系运算符，书籍的信息没有逻辑上的大小关系。  

## [练习14.20](ex14_20)
> 为你的 Sales_data 类定义加法和复合赋值运算符。

## [练习14.21](ex14_21)
> 编写 Sales_data 类的 + 和+= 运算符，使得 + 执行实际的加法操作而 += 调用+。相比于 14.3 节（第 497 页）和 14.4 节（第 500 页）对这两个运算符的定义，本题的定义有何缺点？试讨论之。

对于`+`运算符，二者没有区别。  
对于`+=`运算符，本题的定义多进行了一次拷贝构造和一次拷贝赋值，效率较低。  

## [练习14.22](ex14_22)
> 定义赋值运算符的一个新版本，使得我们能把一个表示 ISBN 的 string 赋给一个 Sales_data 对象。

## [练习14.23](ex14_23)
> 为你的 StrVec 类定义一个 initializer_list 赋值运算符。

## 练习14.24
> 你在 7.5.1 节中的练习 7.40（第 261 页）中曾经选择并编写了一个类，你认为它应该含有拷贝赋值和移动赋值运算符吗？如果是，请实现它们。

它应该含有，因为其数据成员有`string`，可以从移动操作中受益。  
由于该类没有定义任何拷贝控制成员，且`string`类定义了它自己的移动操作，因此编译器会为其定义合成的拷贝赋值和移动赋值运算符。  

## 练习14.25
> 上题的这个类还需要定义其他赋值运算符吗？如果是，请实现它们；同时说明运算对象应该是什么类型并解释原因。

不需要，书籍信息类不需要从其他类型对象赋值。  

## [练习14.26](ex14_26)
> 为你的 StrBlob 类、StrBlobPtr 类、StrVec 类和 String 类定义下标运算符。

## [练习14.27](ex14_27)
> 为你的 StrBlobPtr 类添加递增和递减运算符。

## [练习14.28](ex14_28)
> 为你的 StrBlobPtr 类添加加法和减法运算符，使其可以实现指针的算术运算（参见 3.5.3 节，第 106 页）。

## 练习14.29
> 为什么不定义 const 版本的递增和递减运算符？

因为递增或递减运算符需要改变对象本身的值，所以不能定义成`const`。  

## 练习14.30
> 为你的 StrBlobPtr 类和在 12.1.6 节练习 12.22（第 423 页）中定义的 ConstStrBlobPtr 类分别添加解引用运算符和箭头运算符。注意：因为 ConstStrBlobPtr 的数据成员指向const vector，所以 ConstStrBlobPtr 中的运算符必须返回常量引用。

## 练习14.31
> 我们的 StrBlobPtr 类没有定义拷贝构造函数、赋值运算符以及析构函数，为什么？

`StrBlobPtr`的数据成员是`weak_ptr`和`size_t`类型，`weak_ptr`类型定义了自己的拷贝控制成员，`size_t`是内置类型，因此编译器合成的拷贝控制成员已能够实现所需的操作。  

## [练习14.32](ex14_32/ex14_32.cpp)
> 定义一个类令其含有指向 StrBlobPtr 对象的指针，为这个类定义重载的箭头运算符。

将该类重载的箭头运算符的返回值定义为引用或者指针都是可行的，二者有一定的差别。  
当返回值自身是类类型时，若它也具有重载的箭头运算符，则会递归调用，直至递归的重载箭头运算符返回一个指针。最后会自动对该指针调用内置版本的箭头运算符。  
因此，箭头运算符递归链上返回指针的那个函数，决定了在该指针所指的类型上进行成员访问。  
对于本题，定义为`StrBlobPtr*`意味着箭头运算符最终将在`StrBlobPtr`上进行成员访问；定义为`StrBlobptr&`意味着箭头运算符将在`string`上进行成员访问。  

## 练习14.33
> 一个重载的函数调用运算符应该接受几个运算对象？

任意个，取决于调用函数对象时，希望传入多少个实参。  

## [练习14.34](ex14_34.cpp)
> 定义一个函数对象类，令其执行 if-then-else 的操作：该类的调用运算符接受三个形参，它首先检查第一个形参，如果成功返回第二个形参值；如果不成功返回第三个形参的值。

## [练习14.35](ex14_35.cpp)
> 编写一个类似于 PrintString 的类，令其从 istream 中读取一行输入，然后返回一个表示我们所读内容的 string。如果读取失败，返回空 string。

## [练习14.36](ex14_36.cpp)
> 使用前一个练习定义的类读取标准输入，将每一行保存为 vector 的一个元素。

## [练习14.37](e14_37.cpp)
> 编写一个类令其检查两个值是否相等。使用该对象及标准库算法编写程序，令其替换某个序列中具有给定值的所有实例。

## [练习14.38](ex14_38/ex14_38.cpp)

> 编写一个类令其检查某个给定的 string 对象的长度是否与一个阈值相等。使用该对象编写程序，统计并报告在输入的文件中长度为 1 的单词有多少个、长度为 2 的单词有多少个、······、长度为 10 的单词又有多少个。

## [练习14.39](ex14_39/ex14_39.cpp)
> 修改上一题的程序令其报告长度在 1 至 9 之间的单词有多少个、长度在 10 或以上的单词又有多少个。

## [练习14.40](ex14_40.cpp)
> 重新编写 10.3.2 节（第 349 页）的 biggies 函数，使用函数对象替换其中的 lambda 表达式。

## 练习14.41
> 你认为 C++ 11 新标准为什么要增加 lambda？对于你自己来说，什么情况下会使用 lambda，什么情况下会使用类？

`lambda`是通过未命名类的的未命名对象来实现的，它在语法形式上更加简单。  
当需要一个可调用对象，而它不会在其他地方使用时，使用`lambda`，因为它更简洁。  
当需要多次使用一个可调用对象时，又或者需要额外保存其他数据时，使用类更合适。  

## [练习14.42](ex14_42)
> 使用标准库函数对象及适配器定义一条表达式，令其
> (a) 统计大于 1024 的值有多少个。 
> (b) 找到第一个不等于 pooh 的字符串。
> (c) 将所有的值乘以2。

## [练习14.43](ex14_43.cpp)
> 使用标准库函数对象判断一个给定的 int 值是否能被 int 容器中的所有元素整除。

## [练习14.44](ex14_44.cpp)
> 编写一个简单的桌面计算器使其能处理二元运算。

## [练习14.45](ex14_45)
> 编写类型转换运算符将一个 Sales_data 对象分别转换成 string 和 double，你认为这些运算符的返回值应该是什么？

转换成`string`的返回值应该是`bookNo`。  
转换成`double`的返回值既可以是`revenue`也可以是`avg_price()`。  

## 练习14.46
> 你认为应该为 Sales_data 类定义上面两种类型转换运算符吗？应该把它们声明成 explicit 的吗？为什么？

不应该定义上面两种转换运算符，`Sales_data`的数据成员`bookNo`、`units_sold`和`revenue`三者合起来才是一个有效的数据，转换成某一个数据成员的类型是没有意义的。  
如果确实需要定义这两个类型转换运算符，应该声明成`explicit`的，可以防止`Sales_data`被默认转换成`string`和`double`类型造成一些出乎意料的结果。  

## 练习14.47
> 说明下面这两个类型转换运算符的区别。
```cpp
struct Integral {
	operator const int();
	operator int() const;
};
```
两个类型转换运算符通过`this`指针是否是常量进行重载，第一个类型转换运算符将返回值设置为`const int`，虽然合法但与返回`int`没有任何区别。  
当对象是常量时，将调用第二个类型转换运算符，当对象不是常量时，将调用第一个类型转换运算符。  

## 练习14.48 
> 你在 7.5.1 节的练习 7.40（第 261 页）中曾经选择并编写了一个类，你认为它应该含有向 bool 的类型转换运算符吗？如果是，解释原因并说明该运算符是否应该是 explicit 的；如果不是，也请解释原因。

`Book`类不应该含有向`bool`的类型转换运算符，逻辑上是没有意义的。  

## 练习14.49
> 为上一题提到的类定义一个转换目标是 bool 的类型转换运算符，先不用在意这么做是否应该。
```cpp
explicit operator bool() { return name.empty() ? false : true; }
```

## 练习14.50
> 在初始化 ex1 和 ex2 的过程中，可能用到哪些类类型的转换序列呢？说明初始化是否正确并解释原因。
```cpp
struct LongDouble {
	LongDouble(double = 0.0);
	operator double();
	operator float();
};
LongDouble ldObj;
int ex1 = ldObj;
float ex2 = ldObj;
```
`ex1`非法，它需要把`LongDouble`转换成`int`，但该类没有定义对应的类型转换运算符，它会尝试其他的类型转换运算符，`double`和`float`的类型转换运算符都可以经过一次算术类型转换变成`int`，不存在哪个优于另一个，因此调用具有二义性。  
`ex2`合法，它需要把`LongDouble`转换成`float`，而`LongDouble`定义了向`float`的类型转换运算符。  

## 练习14.51
> 在调用 calc 的过程中，可能用到哪些类型转换序列呢？说明最佳可行函数是如何被选出来的。
```cpp
void calc(int);
void calc(LongDouble);
double dval;
calc(dval);  //哪个calc？
```
两个`calc`函数都是可行函数。  
对于`calc(int)`，需要将`double`类型的参数转换为`int`类型。  
对于`calc(LongDouble)`，需要将`double`类型转换为`LongDouble`类型。  
根据函数匹配时的参数转换优先级，通过算术类型转换的优先级要高于类类型转换实现的匹配。因此最佳可行函数是 `calc(int)`。  

## 练习14.52
> 在下面的加法表达式中分别选用了哪个 operator+ ？列出候选函数、可行函数及为每个可行函数的实参执行的类型转换：
```cpp
struct Longdouble {
	// 用于演示的成员operator+; 在通常情况下+是个非成员
	LongDouble operator+(const SmallInt&);
	// 其他成员与 14.9.2 节（第 521 页）一致
};
LongDouble operator+(LongDouble&, double);
SmallInt si;
LongDouble ld;
ld = si + ld;
ld = ld + si;
```

对于`ld = si + ld`，左侧运算对象是`SmallInt`类，因此候选函数包括`SmallInt`类的成员版本、`SmallInt`和`LongDouble`的非成员版本，以及内置版本，即：  
1. `SmallInt operator+(const SmallInt &, const SmallInt &)`
2. `LongDouble operator+(LongDouble &, double)`
3. 内置加法运算符

由于`LongDouble`无法转换为第二个参数要求的`SmallInt`，因此第一个不是可行函数。  
由于`SmallInt`无法转换为第一个参数要求的`LongDouble`，因此第二个不是可行函数。  
由于`SmallInt`可以转换为`int`，`LongDouble`可以转换为`double`或`float`，因此内置加法运算符`operator+(int,float)`和`operator(int,double)`都是可行函数。对于第二个参数，`LongDouble`的两个类型转换运算符哪一个都不优于另一个，因此调用具有二义性。  
  
对于`ld = ld + si`，左侧运算对象是`LongDouble`类，因此候选函数包括`LongDouble`类的成员版本、`SmallInt`和`LongDouble`的非成员版本，以及内置版本，即：  
1. `LongDouble operator+(const SmallInt&)`
2. `SmallInt operator+(const SmallInt &, const SmallInt &)`
3. `LongDouble operator+(LongDouble &, double)`
4. 内置加法运算符

第一个候选函数是可行函数，它的参数是精确匹配的。  
第二个候选函数，由于`LongDouble`无法转换为第一个参数要求的`SmallInt`，因此不是可行函数。  
第三个候选函数是可行函数，第二个参数需要将`SmallInt`转换为`double`。    
第四个（组）候选函数中的`operator+(double,int)`和`operator+(float,int)`是可行函数，都需要将类类型转换为算术类型。  
可行函数`LongDouble operator+(const SmallInt&)`是精确匹配，因此会调用它。  

## 练习14.53
> 假设我们已经定义了如第 522 页所示的 SmallInt，判断下面的加法表达式是否合法。如果合法，使用了哪个加法运算符？如果不合法，应该怎样修改代码才能使其合法？
```cpp
SmallInt si;
double d = si + 3.14;
```
可行函数包括：  
1. `SmallInt operator+(const SmallInt &, const SmallInt &)`
2. 内置加法运算符`operator+(int,double)`

对于第一个参数，第一个可行函数是精确匹配，第二个可行函数需要将`SmallInt`转换为`int`。  
对于第二个参数，第一个可行函数需要将`double`转换为`SmallInt`，第二个可行函数是精确匹配。  
两个可行函数各自在一个参数上实现了精确匹配，又都需要进行类类型转换，不存在哪一个优于另一个，因此调用具有二义性。  

若想调用第一个可行函数，应改为：  
`double d = si + SmallInt(3.14)`  
若想调用第二个可行函数，应改为：  
`double d = static_cast<int>(si) + 3.14;`  