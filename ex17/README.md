## 练习17.1
> 定义一个保存三个 int 值的 tuple，并将其成员分别初始化为 10、20 和 30。
```cpp
tuple<int, int, int> t(10, 20, 30);
```

## 练习17.2
> 定义一个 tuple，保存一个 string、一个 vector< string > 和一个 pair< string, int >。
```
tuple<string, vector<string>, pair<string, int>> t;
```

## [练习17.3](ex17_03)
> 重写 12.3 节（第 430 页）中的 TextQuery 程序，使用 tuple 代替 QueryResult 类。你认为哪种设计更好？为什么？

若查询结果仅是临时使用，例如现在的输出后丢弃，使用`tuple`比定义类要简单.。  
若查询结果还要进行其他处理，在`QueryResult`类中定义相关操作要更合适。另一个缺点是只能使用下标访问`tuple`的元素，不能使用一个易记的名字。  

## [练习17.4](ex17_04/main.cpp)
> 编写并测试你自己版本的 findBook 函数。

## [练习17.5](ex17_05/main.cpp)
> 重写 findBook，令其返回一个 pair，包含一个索引和一个迭代器 pair。

## [练习17.6](ex17_06/main.cpp)
> 重写 findBook，不使用 tuple 和 pair。

## 练习17.7
> 解释你更倾向于哪个版本的 findBook，为什么。

对于`findBook`，更倾向于`tuple`版本，因为它编写简单。但如果要进行复杂计算或者封装，还是类的版本更合适。  

## 练习17.8
> 在本节最后一段代码中，如果我们将 Sales_data() 作为第三个参数传递给 accumulate，会发生什么？

`Sales_data()`默认构造函数除了会将卖出本书和销售量置为`0`，还会将`bookNo`设为空串，而加法运算符的结果的`bookNo`是左侧运算对象的`bookNo`，这导致结果中看不到书籍的ISBN号。  

## 练习17.9
> 解释下列每个 bitset 对象所包含的位模式：
```cpp
(a) bitset<64> bitvec(32);
(b) bitset<32> bv(1010101);
(c) string bstr; cin >> bstr; bitset<8> bv(bstr);
```
(a) `bitvec`总共有`64`位，低`6`位是`100000`，其他位均为`0`。  
(b) `bv`总共有`32`位，低`20`位是`‭11110110100110110101‬`，其他位是`0`。  
(c) `vc`总共有`8`位，用输入的字符串来对`bv`进行初始化，要求字符串必须只由字符`0`或字符`1`组成，否则会抛出`invalid_argument`异常，下标最大的被用来初始化低位。如果字符串大小小于`8`则其他位为`0`，如果大于`8`则字符串下标范围`[0,bstr.size() - 8)`被抛弃。      

## [练习17.10](ex17_10.cpp)
> 使用序列 1、2、3、5、8、13、21 初始化一个 bitset，将这些位置置位。对另一个 bitset 进行默认初始化，并编写一小段程序将其恰当的位置位。

## [练习17.11](ex17_11.cpp)
> 定义一个数据结构，包含一个整型对象，记录一个包含 10 个问题的真/假测验的解答。如果测验包含 100 道题，你需要对数据结构做出什么改变（如果需要的话）？

数据结构本身不变，用户代码需要改变模板参数。  

## [练习17.12](ex17_12.cpp)
> 使用前一题中的数据结构，编写一个函数，它接受一个问题编号和一个表示真/假解答的值，函数根据这两个参数更新测验的解答。

## [练习17.13](ex17_13.cpp)
> 编写一个整型对象，包含真/假测验的正确答案。使用它来为前两题中的数据结构生成测验成绩。

## [练习17.14](ex17_14.cpp)
> 编写几个正则表达式，分别触发不同错误。运行你的程序，观察编译器对每个错误的输出。

## [练习17.15](ex17_15.cpp)
> 编写程序，使用模式查找违反“i在e之前，除非在c之后”规则的单词。你的程序应该提示用户输入一个单词，然后指出此单词是否符合要求。用一些违反和未违反规则的单词测试你的程序。

## [练习17.16](ex17_16.cpp)
> 如果前一题程序中的 regex 对象用 "[^c]ei" 进行初始化，将会发生什么？用此模式测试你的程序，检查你的答案是否正确。

如果匹配成功，`smatch`中保存的将是三个字符：任意非`c`字符和`ei`。而不是之前的完整单词。  

## [练习17.17](ex17_17.cpp)
> 更新你的程序，令它查找输入序列中所有违反"ei"语法规则的单词。

## [练习17.18](ex17_18.cpp)
> 修改你的程序，忽略包含“ei”但并非拼写错误的单词，如“albeit”和“neighbor”。

## 练习17.19
> 为什么可以不先检查 m[4] 是否匹配了就直接调用 m[4].str()？

有几个子表达式，`smatch`就有几个`ssub_match`对象，因此可以直接调用`m[4]`。如果子表达式没有匹配上，`ssub_match.str()`会返回空串。  

## [练习17.20](ex17_20.cpp)
> 编写你自己版本的验证电话号码的程序。

## [练习17.21](ex17_21/main.cpp)
> 使用本节中定义的 valid 函数重写 8.3.2节（第 289 页）中的电话号码程序。

## [练习17.22](ex17_22/main.cpp)
> 重写你的电话号码程序，使之允许在号码的三个部分之间放置任意多个空白符。

## [练习17.23](ex17_23.cpp)
> 编写查找邮政编码的正则表达式。一个美国邮政编码可以由五位或九位数字组成。前五位数字和后四位数字之间可以用一个短横线分隔。

## [练习17.24](ex17_24/main.cpp)
> 编写你自己版本的重排电话号码格式的程序。

## [练习17.25](ex17_25/main.cpp)
> 重写你的电话号码程序，使之只输出每个人的第一个电话号码。

## [练习17.26](ex17_26/main.cpp)
> 重写你的电话号码程序，使之对多于一个电话号码的人只输出第二个和后续号码。

## [练习17.27](ex17_27/main.cpp)
> 编写程序，将九位数字邮政编码的格式转换为 ddddd-dddd。

## [练习17.28](ex17_28.cpp)
> 编写函数，每次调用生成并返回一个均匀分布的随机 unsigned int。

## [练习17.29](ex17_29.cpp)
> 修改上一题中编写的函数，允许用户提供一个种子作为可选参数。

## [练习17.30](ex17_30.cpp)
> 再次修改你的程序，此次增加两个参数，表示函数允许返回的最小值和最大值。

## 练习17.31
> 对于本节中的游戏程序，如果在 do 循环内定义 b 和 e，会发生什么？

每次循环都会创建一个新的由默认种子初始化的引擎和新的伯努利分布，`b(e)`的结果永远是固定的，游戏先行者不会改变。  

## 练习17.32
> 如果我们在循环内定义 resp，会发生什么？

出现编译错误，在循环体内定义的变量只在循环体内可见，循环条件部分使用的变量必须定义在循环体之外。  

## [练习17.33](ex17_33/main.cpp)
> 修改 11.3.6 节（第 392 页）中的单词转换程序，允许对一个给定单词有多种转换方式，每次随机选择一种进行实际转换。

## [练习17.34](ex17_34.cpp)
> 编写一个程序，展示如何使用表 17.17 和表 17.18 中的每个操纵符。

## [练习17.35](ex17_35.cpp)
> 修改第 670 页中的程序，打印 2 的平方根，但这次打印十六进制数字的大写形式。

## [练习17.36](ex17_36.cpp)
> 修改上一题中的程序，打印不同的浮点数，使它们排成一列。

## [练习17.37](ex17_37/main.cpp)
> 用未格式化版本的 getline 逐行读取一个文件。测试你的程序，给定一个文件，既包含空行又包含长度超过你传递给 geiline 的字符数组大小的行。

## [练习17.38](ex17_38/main.cpp)
> 扩展上一题中你的程序，将读入的每个单词打印到它所在的行。

## [练习17.39](ex17_39/main.cpp)
> 对本节给出的 seek 程序，编写你自己的版本。