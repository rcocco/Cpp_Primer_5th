## 练习6.1
> 实参和形参的区别是什么？

形参在函数定义时使用，形参列表可以包含任意多个形参，多个形参之间用逗号分隔。形参规定了函数接受数据的类型和数量。  
实参在函数调用时使用，实参的数量和形参一样多。实参的作用是初始化对应形参，实参的类型必须与对应形参类型匹配。  

## 练习6.2
> 请指出下列函数哪个有错误，为什么？应该如何修改这些错误呢？
```cpp
(a) int f() {
         string s;
         // ...
         return s;
    }
(b) f2(int i) { /* ... */ }
(c) int calc(int v1, int v1) /* ... */ }
(d) double square (double x)  return x * x; 
```

(a) `return`语句返回的结果必须与函数定义的返回类型匹配。应改为：  
```cpp
string f() {
	string s;
	// ...
	return s;
}
```
(b) 函数定义必须提供一个返回类型，如果函数不返回任何值，它应该采用`void`返回类型。应改为：  
```cpp
void f2(int i) { /* ... */ }
```
(c) 函数的任意两个形参都不能同名，且函数体的左花括号丢失。应改为：  
```cpp
int calc(int v1, int v2) { /* ... */ }
```
(d) 函数执行的操作必须放在语句块中。应改为：  
```cpp
double square (double x) { return x * x; } 
```

## [练习6.3](ex06_03.cpp)
> 编写你自己的 fact 函数，上机检查是否正确。

## [练习6.4](ex06_04.cpp)
> 编写一个与用户交互的函数，要求用户输入一个数字，计算生成该数字的阶乘。在main函数中调用该函数。

## [练习6.5](ex06_05.cpp)
> 编写一个函数输出其实参的绝对值。

## [练习6.6](ex06_06.cpp)
> 说明形参、局部变量以及局部静态变量的区别。编写一个函数，同时用到这三种形式。

形参和定义在函数体内部的变量统称为局部变量，它们仅在函数的作用域可见，局部变量还会隐藏在外层作用域中同名的其他所有声明。  
局部变量又分为普通局部变量和静态局部变量。  
对于普通局部变量来说，当函数的控制路径经过变量定义语句时创建该对象，如果定义语句提供了初始值，则用该值进行初始化，否则会进行默认初始化，当到达定义所在的块末尾时变量被销毁。   对于静态局部变量来说，当函数的控制路径第一次经过变量定义语句时创建该对象，未提供初始值时进行值初始化，直到程序终止才被销毁。  

## [练习6.7](ex06_07.cpp)
> 编写一个函数，当它第一次被调用时返回 0，以后每次被调用返回值加 1。

## [练习6.8](Chapter6.h)
> 编写一个名为 Chapter6.h 的头文件，令其包含 6.1 节练习（第 184 页）中的函数声明。

## [练习6.9](ex06_09)
> 编写你自己的 fact.cc 和 factMain.cc ，这两个文件都应该包含上一小节的练习中编写的 Chapter6.h 头文件。通过这些文件，理解你的编译器是如何支持分离式编译的。

## [练习6.10](ex6_10.cpp)
> 编写一个函数，使用指针形参交换两个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。

## [练习6.11](ex06_11.cpp)
> 编写并验证你自己的 reset 函数，使其作用于引用类型的参数。

## [练习6.12](exercise6_12.cpp)
> 改写 6.2.1 节中练习 6.10 （第 188 页）的程序，使其引用而非指针交换两个整数的值。你觉得哪种方法更易于使用呢？为什么？

引用形式更易于使用，它不需要在实参中使用取地址操作符，也避免了拷贝指针值的开销。  

## 练习6.13
> 假设 T 是某种类型的名字，说明以下两个函数声明的区别：一个是 void f(T)，另一个是 void f(&T)。

`void f(T)`函数的实参被值传递，实参的值被拷贝给形参，形参和实参是两个独立的变量，在函数体内修改形参的值不会改变实参。  
`void f(&T)`函数的实参被引用传递，形参是实参的别名，形参绑定到实参上，在函数体内修改形参的值将改变实参。  

## 练习6.14
> 举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。

当函数的实参是 IO 类型时，形参必须是引用类型，因为 IO 类型不支持拷贝操作。  
当函数的实参是字面值类型时，形参不能是引用类型，因为普通引用不能绑定到字面值上，但形参可以是常量引用类型。  

## 练习6.15
> 说明 find_char 函数中的三个形参为什么是现在的类型，特别说明为什么 s 是常量引用而 occurs 是普通引用？为什么 s 和 occurs 是引用类型而 c 不是？如果令 s 是普通引用会发生什么情况？如果令 occurs 是常量引用会发生什么情况？

1. 为了避免拷贝字符串带来的开销，形参`s`是引用类型。  
2. 形参`c`是`char`类型，它只占 1 字节，开销很小，因此值传递或引用传递都可以，又因为调用时经常会使用字面值，若将它设为引用则只能设为常量引用。  
3. 形参`occurs`是引用类型，是因为函数除了返回值之外，还希望通过该引用形参返回额外的信息。  
4. `s`是常量引用，因为函数体中不会修改字符串。`occurs`是普通引用，因为函数体中需要对其进行递增来计数。  
5. 若`s`是普通引用，函数体内将有可能误修改字符串导致实参被修改，同时也会导致无法传递给`s`一个字符串字面值，虽然标准库允许将字符串字面值转换为`string`对象，但普通引用无法绑定到一个需要转换的对象上面。
6. 若`occurs`是常量引用，那么函数体内递增出现次数`++occurs;`的语句将出现编译错误，因为无法修改一个常量引用的值。  

## 练习6.16
> 下面的这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善。
```cpp
bool is_empty(string& s) { return s.empty(); }
```

不能将`const`对象、字面值或需要类型转换的对象传递给普通引用的形参，因此传递给这个函数`string`常量或者字符串字面值都是非法的。形参应改为常量引用：
```cpp
bool is_empty(const string& s) { return s.empty(); }
```

## [练习6.17](ex96_17.cpp)
> 编写一个函数，判断 string 对象中是否含有大写字母。编写另一个函数，把 string 对象全都改写成小写形式。在这两个函数中你使用的形参类型相同吗？为什么？

## 练习6.18
> 为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。
> (a) 名为 compare 的函数，返回布尔值，两个参数都是 matrix 类的引用。 
> (b) 名为 change_val 的函数，返回 vector< int > 的迭代器，有两个参数：一个是 int，另一个是 vector< int > 的迭代器。

(a) `bool compare(matrix&, matrix&);`    
该函数比较两个`matrix`对象并返回布尔值。  
(b) `vector<int>::iterator change_val(int, vector<int>::iterator);`  
该函数将形参中的迭代器所指向的元素修改为形参中的`int`变量，然后返回指向该位置的迭代器。  

## 练习6.19
> 假定有如下声明，判断哪个调用合法、哪个调用不合法。对于不合法的函数调用，说明原因。
```cpp
double calc(double);
int count(const string &, char);
int sum(vector<int>::iterator, vector<int>::iterator, int);
vector<int> vec(10);
(a) calc(23.4, 55.1);    (b) count("abcda",'a');
(c) calc(66);            (d) sum(vec.begin(), vec.end(), 3.8);
```

(a) 不合法，因为实参的数量多于形参的个数。  
(b) 合法。常量引用`const string &`可以绑定到字符串字面值。  
(c) 合法，整型字面值`66`可以转换为实参的类型`double`。  
(d) 合法，浮点型字面值`3.8`可以转换为实参的类型`int`。

## 练习6.20
> 引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么情况？

只要不打算改变引用形参的值，都应该设为常量引用。  
应该是常量引用表明不打算改变对象的值，设为普通引用将有可能误修改该对象。同时也导致无法给函数传递常量对象、字面值或需要类型转换的对象。  

## [练习6.21](ex06_21.cpp)
> 编写一个函数，令其接受两个参数：一个是 int 型的数，另一个是 int 指针。函数比较 int 的值和指针所指的值，返回较大的那个。在该函数中指针的类型应该是什么？

 `const int *` 类型。

## [练习6.22](ex06_22.cpp)
> 编写一个函数，令其交换两个 int 指针。

## [练习6.23](ex06_23.cpp)
> 参考本节介绍的几个 print 函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的 i 和 j:
```cpp
int i = 0, j[2] = { 0, 1 };
```

## 练习6.24
> 描述下面这个函数的行为。如果代码中存在问题，请指出并改正。
```cpp
void print(const int ia[10]) {
	for (size_t i = 0; i != 10; ++i)
		cout << ia[i] << endl;
}
```

当数组作为形参时，传递给函数的数组会被转换成指向数组首元素的指针。  
该函数的实际形参是`const int *`，编译器不会检查形参中所写的数组的维度。因此即使传递的不是维度为`10`的数组，`print`函数依然可以正常调用。如果传递进来的数组维度大于`10`，函数会输出前十个数，如果传递进来的数组维度小于`10`，将会导致下标越界。  
为了保证传入的数组是维度为`10`的数组，形参应改为数组的引用：  
```cpp
void print(const int (&ia)[10]) {
	for (size_t i = 0; i != 10; ++i)
		cout << ia[i] << endl;
}
```

## [练习6.25](ex06_25.cpp)
> 编写一个 main 函数，令其接受两个实参。把实参的内容连接成一个 string 对象并输出出来。

## [练习6.26](ex06_25.cpp)
> 编写一个程序，使其接受本节所示的选项；输出传递给 main 函数的实参的内容。

## [练习6.27](ex06_27.cpp)
> 编写一个函数，它的参数是initializer_list< int >类型的对象，函数的功能是计算列表中所有元素的和。

## 练习6.28
> 在 error_msg 函数的第二个版本中包含 ErrCode 类型的参数，其中循环内的 elem 是什么类型？

`elem` 是 `const string &` 类型。

## 练习6.29
> 在范围 for 循环中使用 initializer_list 对象时，应该将循环控制变量声明成引用类型吗？为什么？

引用类型的优势是可以直接操作所引用的对象并且避免拷贝较为复杂的类类型对象，因为`initializer_list`对象的元素是常量值，所以只能声明为常量引用。  
对于开销较小的内置类型，既可以声明为引用类型也可以不声明为引用类型。  

## [练习6.30](ex06_30.cpp)
> 编译第 200 页的 str_subrange 函数，看看你的编译器是如何处理函数中的错误的。

Visual Studio 2017：
- 1>ex06_30.cpp(10): error C2561: “str_subrange”: 函数必须返回值
- 1>ex06_30.cpp(3): note: 参见“str_subrange”的声明

## 练习6.31
> 什么情况下返回的引用无效？什么情况下返回常量的引用无效？

如果返回的引用所引的是函数的局部变量时，则随着函数的结束返回的引用也失效了。如果引用所引的是函数开始之前就已经存在对象，则返回的引用是有效的。  
如果返回的常量的引用所引的是函数的局部变量时，引用无效。如果希望返回一个可修改的左值，此时返回常量的引用也是不正确的。  

## 练习6.32
> 下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释原因。
```cpp
int &get(int *array, int index) { return array[index]; }
int main() {
    int ia[10];
    for (int i = 0; i != 10; ++i)
        get(ia, i) = i;
}
```

合法，函数返回数组中`index`位置的元素的引用，因此可以对其进行修改。`main`函数中通过循环将数组`ia`初始化`0`到`9`。

## [练习6.33](exercise6_33.cpp)
> 编写一个递归函数，输出 vector 对象的内容。

## 练习6.34
> 如果 factorial 函数的停止条件如下所示，将发生什么情况？
```cpp
if (val != 0)
```
如果传递给函数的是一个负数，条件将永远满足，导致了递归循环无法终止。  

## 练习6.35
> 在调用 factorial 函数时，为什么我们传入的值是 val-1 而非 val--？

后置递减返回的是递减前的原值的副本，这导致每次传入的参数都是相同的，递归将无法终止。

## 练习6.36
> 编写一个函数声明，使其返回数组的引用并且该数组包含 10 个 string 对象。不用使用尾置返回类型、decltype 或者类型别名。
```cpp
string (&func())[10];
```

## 练习6.37
> 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用 decltype 关键字。你觉得哪种形式最好？为什么？
```cpp
typedef string strarr10[10];
string arr[10];

strarr10 &func();
auto func()->string(&)[10];
decltype(arr) &func();
```
尾置返回类型最好，不需要额外语句，最清晰明了。类型别名需要预先`typedef`，`decltype`需要存在一个定义好的数组。  

## 练习6.38
> 修改 arrPtr 函数，使其返回数组的引用。
```cpp
decltype(odd) &arrPtr(int i) {
    return (i % 2) ? odd : even;
}
```

## 练习6.39
> 说明在下面的每组声明中第二条语句是何含义。如果有非法的声明，请指出来。
```cpp
(a) int calc(int, int);
	int calc(const int, const int);
(b) int get();
	double get();
(c) int *reset(int *);
	double *reset(double *);
```

(a) 第二个声明非法，它的含义是声明一个只接受整型常量实参的函数，但顶层`const`会被忽略掉，因此两个函数实际参数是相同的。  
(b) 第二个声明非法，它试图通过返回类型区分两个同名函数，但重载函数必须在形参数量或形参类型上有所不同，不能只有返回类型不同。  
(c) 第二个声明合法，声明了一个同名但接受类型为`double`的函数。  

## 练习6.40
> 下面的哪个声明是错误的？为什么？
```cpp
(a) int ff(int a, int b = 0, int c = 0);
(b) char *init(int ht = 24, int wd, char bckgrnd);		
```
(b) 是错的，因为一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  

## 练习6.41
> 下面的哪个调用是非法的？为什么？哪个调用虽然合法但显然与程序员的初衷不符？为什么？
```cpp
char *init(int ht, int wd = 80, char bckgrnd = ' ');
(a) init();
(b) init(24, 10);
(c) init(14, '*');
```
(a) 非法，没有提供为形参`ht`提供参数。  
(b) 合法。
(c) 合法，但与初衷不符，原意是将字符`*`作为背景，但实际传递给函数中的参数分别是`ht = 14, wd = '*', bckgrnd = ' '`。字符`*`被转换成了`int`类型传递给了`wd`。  

## [练习6.42](exercise6_42.cpp)
> 给 make_plural 函数的第二个形参赋予默认实参 's',  利用新版本的函数输出单词 success 和 failure 的单数和复数形式。

## 练习6.43
> 你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？
```cpp
(a) inline bool eq(const BigInt&, const BigInt&) {...}
(b) void putValues(int *arr, int size);
```
(a) 是一个内联函数的定义，它应该放在头文件中。因为在编译一个使用内联函数的源文件时，编译器为了将内联函数调用展开，必须看到内联函数的定义，而不能像普通函数一样只看到声明。因此在每一个使用该内联函数的源文件中，都必须定义一遍相同内联函数。如果多个文件中的内联函数定义不一致，最终会采用哪一个是未定义的。放在头文件中，就保证了在`include`头文件时会包含该内联函数的定义。  
(b) 是一个普通函数的声明，应该放在头文件中。  

## 练习6.44
> 将 6.2.2 节（第 189 页）的 isShorter 函数改写成内联函数。
```cpp
inline bool isShorter(const string &s1, const string &s2) {
	return s1.size() < s2.size();
}
```

## 练习6.45
> 回顾在前面的练习中你编写的那些函数，它们应该是内联函数吗？如果是，将它们改写成内联函数；如果不是，说明原因。

前面实现的函数大多规模较小、流程直接，适合改写为内联函数。但包含循环、递归或`switch`结构的不适合改写为内联函数。改写时只需要在函数返回类型前面加上`inline`即可。  

## 练习6.46
> 能把 isShorter 函数定义成 constexpr 函数吗？如果能，将它改写成 constxpre 函数；如果不能，说明原因。

不能。constexpr函数的返回值类型及所有形参都得是字面值类型。在`isShorter`函数中，形参`string`不是字面值类型，而且虽然函数中只有一条`return`语句，但`size()`函数不是`constexpr`函数，所以`s1.size() < s2.size()`表达式也不是常量表达式。  

## [练习6.47](ex06_47.cpp)
> 改写 6.3.2 节（第 205 页）练习中使用递归输出 vector 内容的程序，使其有条件地输出与执行过程有关的信息。例如，每次调用时输出 vector 对象的大小。分别在打开和关闭调试器的情况下编译并执行这个程序。

## 练习6.48
> 说明下面这个循环的含义，它对 assert 的使用合理吗？
```cpp
string s;
while (cin >> s && s != sought) { } //空函数体
assert(cin);
```
循环不断接受用户输入，并检查是否等于`sought`，若用户终止输入或者输入值相等则退出循环。  
`assert`使用不合理，循环的终止有两种情况：用户终止输入、输入值等于`sought`。  
当用户终止输入退出循环时，`cin`为假，`assert`输出信息并终止程序。当用户输入值等于`sought`退出循环时，`cin`为真，`assert`什么也不做。  
而用户总有终止输入的时候，这种情况不能算程序错误，因此输出错误信息并终止程序是不合理的。  

## 练习6.49
> 什么是候选函数？什么是可行函数？

- **候选函数**：与被调用的函数同名，并且其声明在调用点可见。  
- **可行函数**：形参数量与调用提供的实参数量相等，并且每个实参类型与对应的形参类型相同或者能转换成形参的类型。  

## 练习6.50
> 已知有第 217 页对函数 f 的声明，对于下面的每一个调用列出可行函数。其中哪个函数是最佳匹配？如果调用不合法，是因为没有可匹配的函数还是因为调用具有二义性？
```cpp
(a) f(2.56, 42)
(b) f(42)
(c) f(42, 0)
(d) f(2.56, 3.14)
```
(a) `f(2.56, 42)` 
- 可行函数：
1. `f(int, int)`
2. `f(double, double = 3.14)`
- 最佳匹配：
1. 就第一个参数`2.56`来说，第二个可行函数是精确匹配，优于第一个。
2. 就第二个参数`42`来说，第一个可行函数是精确匹配，优于第二个。
- 结果：
不合法，没有一个函数优于另一个，调用具有二义性。  

(b) `f(42)`  
- 可行函数：
1. `f(int)`
2. `f(double, double = 3.14)`
- 最佳匹配：
1. 就第一个参数`42`来说，第一个可行函数是精确匹配，优于第二个。
- 结果：
`f(int)`是最佳匹配。  

(c) `f(42, 0)`  
- 可行函数：
1. `f(int, int)`
2. `f(double, double = 3.14)`
- 最佳匹配：
1. 就第一个参数`42`来说，第一个可行函数是精确匹配，优于第二个。
2. 就第二个参数`0`来说，第一个可行函数是精确匹配，优于第二个。
- 结果：
`f(int, int)`是最佳匹配。  

(d) `f(2.56, 3.14)`  
- 可行函数：
1. `f(int, int)`
2. `f(double, double = 3.14)`
- 最佳匹配：
1. 就第一个参数`2.56`来说，第二个可行函数是精确匹配，优于第一个。
2. 就第二个参数`3.14`来说，第二个可行函数是精确匹配，优于第一个。
- 结果：
`f(double, double = 3.14)`是最佳匹配。  

## [练习6.51](ex06_51.cpp)
> 编写函数 f 的 4 个版本，令其各输出一条可以区分的消息。验证上一个练习的答案，如果你回答错了，反复研究本节内容直到你弄清自己错在何处。

## 练习6.52
> 已知有如下声明：
```cpp
void manip(int ,int);
double dobj;
```
> 请指出下列调用中每个类型转换的等级（参见 6.6.1 节，第 219 页）
```cpp
(a) manip('a', 'z');
(b) manip(55.4, dobj);
```
(a) 第3级。`char`类型提升到了`int`类型。  
(b) 第4级。`double`类型转换为了`int`类型。  

## 练习6.53
> 说明下列每组声明中的第二条语句会产生什么影响，并指出哪些不合法（如果有的话）。
```cpp
(a) int calc(int&, int&); 
	int calc(const int&, const int&); 
(b) int calc(char*, char*);
	int calc(const char*, const char*);
(c) int calc(char*, char*);
	int calc(char* const, char* const);
```
(a) 第二条语句声明了一个重载函数，它接受常量引用。当使用一个整型常量调用`calc`时，会匹配第二个，而使用一个非常量调用`calc`时，会匹配第一个。  
(b) 第二条语句声明了一个重载函数，它接受一个指向常量的指针。当实参是一个常量指针时会匹配第二个，当实参是一个非常量指针时会匹配第一个。  
(c) 第二条语句不合法，根据匹配规则，向实参添加或删除顶层`const`都属于精确匹配，因此它重复声明了第一条语句中的函数没有区别。  

## [练习6.54](ex06_54.cpp)
> 编写函数的声明，令其接受两个 int 形参并返回类型也是 int；然后声明一个 vector 对象，令其元素是指向该函数的指针。

## [练习6.55](ex06_55.cpp)
> 编写 4 个函数，分别对两个 int 值执行加、减、乘、除运算；在上一题创建的 vector 对象中保存指向这些函数的指针。

## [练习6.56](ex06_55.cpp)
> 调用上述 vector 对象中的每个元素并输出其结果。