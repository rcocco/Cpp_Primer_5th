## [练习10.1](ex10_01.cpp)
> 头文件 algorithm 中定义了一个名为 count 的函数，它类似 find， 接受一对迭代器和一个值作为参数。 count 返回给定值在序列中出现的次数。编写程序，读取 int 序列存入vector 中，打印有多少个元素的值等于给定值。

## [练习10.2](ex10_02.cpp)
> 重做上一题，但读取 string 序列存入 list 中。

## [练习10.3](ex10_03.cpp)
> 用 accumulate 求一个 vector< int > 中元素之和。

## [练习10.4](ex10_04.cpp)
> 假定 v 是一个 vector< double >，那么调用 accumulate(v.cbegin(),v.cend(),0) 有何错误（如果存在的话）？

`accumulate`的第三个参数决定了使用哪个类型的加法运算符以及返回类型，参数是`int`类型会导致容器中所有`double`元素被截断为`int`再相加，最后返回的也是一个`int`。  

## 练习10.5
> 在本节对名册（roster）调用 equal 的例子中，如果两个名册中保存的都是 C 风格字符串而不是string，会发生什么？

C 风格字符串实质是以`\0`结尾的字符数组，在`==`运算符的表达式中，使用数组类型对象其实是使用一个指向该数组首元素的指针，而指针的`==`运算符是比较两个指针的值，也就是指针所指向的地址。因此最终比较的是两个 C 风格字符串首字符在内存中的地址是否相同。  

## [练习10.6](ex10_06.cpp)
> 编写程序，使用 fill_n 将一个序列中的 int 值都设置为 0。

## 练习10.7
> 下面程序是否有错误？如果有，请改正：
```cpp
(a) vector<int> vec; list<int> lst; int i;
	while (cin >> i)
		lst.push_back(i);
	copy(lst.cbegin(), lst.cend(), vec.begin());
(b) vector<int> vec;
	vec.reserve(10);
	fill_n(vec.begin(), 10, 0);
```
(a) 有错。算法假定目的序列至少包含与输入序列一样多的元素，而此时`vec`为空。可以改为使用插入迭代器：  
```cpp
copy(lst.cbegin(), lst.cend(), back_inserter(vec));
```
(b) 有错。`reverse`分配了`10`个元素的空间，但算法要求的是目的序列至少包含与输入序列一样多的元素，而不是有多少空间。可以改为之前使用过的插入迭代器，也可以使用`resize`调整容器的元素数量。    
```cpp
vector<int> vec;
vec.resize(10);
fill_n(vec.begin(), 10, 0);
```

## 练习10.8
> 本节提到过，标准库算法不会改变它们所操作的容器的大小。为什么使用 back_inserter 不会使这一断言失效？

严格来说，标准库算法根本不知道“容器”是什么，更不会执行容器操作，它只运行于迭代器之上，通过迭代器来访问元素。  
对于`fill`等拥有目的序列参数的算法，在算法中实际进行的是解引用迭代器并改变其值`*it = val`操作，标准库算法假定目的序列至少与输入序列有一样多的元素，因此`*it = val`总是有效的。  
这类标准库算法对任何迭代器都使用解引用并赋值操作`*it = val`，一般来说，赋值操作显然不会改变容器大小，它只是改变了迭代器所指向位置的值，因此对标准库算法来说，它自身并没有执行任何插入或删除操作。  
对于插入迭代器`back_inserter`，它的解引用并赋值操作`*it = val`其实是将元素添加到了迭代器所指向的目前没有任何元素的位置，就结果而言，它向容器添加了元素。  
会不会插入和删除元素的关键不在于标准库算法，而在于传递给算法的迭代器是否具有这样的能力，更具体的，也就是迭代器所定义的“解引用并赋值”操作做了什么。  

## [练习10.9](ex10_09.cpp)
> 实现你自己的 elimDups。分别在读取输入后、调用 unique 后以及调用 erase 后打印 vector 的内容。

## 练习10.10
> 你认为算法不改变容器大小的原因是什么？

见`练习10.8`。

## [练习10.11](ex10_11.cpp)
> 编写程序，使用 stable_sort 和 isShorter 将传递给你的 elimDups 版本的 vector 排序。打印 vector 的内容，验证你的程序的正确性。

## [练习10.12](ex10_12.cpp)
> 编写名为 compareIsbn 的函数，比较两个 Sales_data 对象的 isbn() 成员。使用这个函数排序一个保存 Sales_data 对象的 vector。

## [练习10.13](ex10_13.cpp)
> 标准库定义了名为 partition 的算法，它接受一个谓词，对容器内容进行划分，使得谓词为 true 的值会排在容器的前半部分，而使谓词为 false 的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为 true 的元素之后的位置。编写函数，接受一个 string，返回一个 bool 值，指出 string 是否有 5 个或更多字符。使用此函数划分 words。打印出长度大于等于 5 的元素。

## [练习10.14](ex10_14.cpp)
> 编写一个 lambda ，接受两个 int，返回它们的和。

## [练习10.15](ex10_15.cpp)
> 编写一个 lambda，捕获它所在函数的 int，并接受一个 int 参数。lambda 应该返回捕获的 int 和 int 参数的和。

## [练习10.16](ex10_16.cpp)
> 使用 lambda 编写你自己版本的 biggies。

## [练习10.17](ex10_17.cpp)
> 重写 10.3.1 节练习 10.12（第 345 页）的程序，在对 sort 的调用中使用 lambda 来代替函数 compareIsbn。

## [练习10.18](ex10_18.cpp)
> 重写 biggies，用 partition 代替 find_if。我们在 10.3.1 节练习 10.13（第 345 页）中介绍了 partition 算法。

## [练习10.19](ex10_19.cpp)
> 用 stable_partition 重写前一题的程序，与 stable_sort 类似，在划分后的序列中维持原有元素的顺序。

## [练习10.20](ex10_20.cpp)
> 标准库定义了一个名为 count_if 的算法。类似 find_if，此函数接受一对迭代器，表示一个输入范围，还接受一个谓词，会对输入范围中每个元素执行。count_if 返回一个计数值，表示谓词有多少次为真。使用 count_if 重写我们程序中统计有多少单词长度超过 6 的部分。

## [练习10.21](ex10_21.cpp)
> 编写一个 lambda，捕获一个局部 int 变量，并递减变量值，直至它变为0。一旦变量变为0，再调用lambda应该不再递减变量。lambda应该返回一个bool值，指出捕获的变量是否为0。

## [练习10.22](ex10_22.cpp)
> 重写统计长度小于等于 6 的单词数量的程序，使用函数代替 lambda。

## 练习10.23
> bind 接受几个参数？

假设`bind`所绑定的可调用对象接受`n`个参数，那么`bind`接受`n+1`个参数。  

## [练习10.24](ex10_24.cpp)
> 给定一个string，使用 bind 和 check_size 在一个 int 的 vector 中查找第一个大于 string 长度的值。

## [练习10.25](ex10_25.cpp)
> 在 10.3.2 节（第 349 页）的练习中，编写了一个使用 partition 的 biggies 版本。使用 check_size 和 bind 重写此函数。

## 练习10.26
> 解释三种迭代器的不同之处。

1. `back_inserter`使用`push_back`插入。  
2. `front_inserter`使用`push_front`插入 。  
3. `inserter`使用`insert`插入，此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。  

## [练习10.27](ex10_27.cpp)
> 除了 unique（参见 10.2.3 节，第 343 页）之外，标准库还定义了名为 unique_copy 的函数，它接受第三个迭代器，表示拷贝不重复元素的目的位置。编写一个程序，使用 unique_copy 将一个 vector 中不重复的元素拷贝到一个初始化为空的 list 中。

## [练习10.28](ex10_28.cpp)
> 一个 vector 中保存 1 到 9，将其拷贝到三个其他容器中。分别使用 inserter、back_inserter 和 front_inserter 将元素添加到三个容器中。对每种 inserter，估计输出序列是怎样的，运行程序验证你的估计是否正确。

假定拷贝到三个空容器`deque`中。  
`inserter(deq1,deq1.begin())`和`back_inserter(deq2)`的输出序列将是顺序的。  
`front_inserter(deq3)`的输出序列将是逆序的。  

## [练习10.29](ex10_29)
> 编写程序，使用流迭代器读取一个文本文件，存入一个 vector 中的 string 里。

## [练习10.30](ex10_30.cpp)
> 使用流迭代器、sort 和 copy 从标准输入读取一个整数序列，将其排序，并将结果写到标准输出。

## [练习10.31](ex10_31.cpp)
> 修改前一题的程序，使其只打印不重复的元素。你的程序应该使用 unique_copy（参见 10.4.1 节，第 359 页）。

## [练习10.32](ex10_32/ex10_32.cpp)
> 重写1.6节（第 21 页）中的书店程序，使用一个 vector 保存交易记录，使用不同算法完成处理。使用 sort 和 10.3.1 节中的 compareIsbn 函数来排序交易记录，然后使用 find 和 accumulate 求和。

## [练习10.33](ex10_33.cpp)
> 编写程序，接受三个参数：一个输入文件和两个输出文件的文件名。输入文件保存的应该是整数。使用 istream_iterator 读取输入文件。使用 ostream_iterator 将奇数写入第一个输出文件，每个值之后都跟一个空格。将偶数写入第二个输出文件，每个值都独占一行。

## [练习10.34](ex10_34.cpp)
> 使用 reverse_iterator 逆序打印一个 vector。

## [练习10.35](ex10_35.cpp)
> 使用普通迭代器逆序打印一个 vector。

## [练习10.36](ex10_36.cpp)
> 使用 find 在一个 int 的 list 中查找最后一个值为0的元素。

## [练习10.37](ex10_37.cpp)
> 给定一个包含 10 个元素的 vector，将位置 3 到 7 之间的元素按逆序拷贝到一个 list 中。

## 练习10.38
> 列出 5 个迭代器类别，以及每类迭代器所支持的操作。

|迭代器类别| 特征  |  支持操作 |  
|:-------| :---  | :------ |  
|输入迭代器|只读、不写；单遍扫描，只能递增|相等性比较、递增、解引用、箭头|  
|输出迭代器|只写、不读；单遍扫描，只能递增|递增、解引用|  
|前向迭代器|可读写；多遍扫描， 只能递增|相等性比较、递增、解引用、箭头|  
|双向迭代器|可读写；多遍扫描，可递增递减|相等性比较、递增、递减、解引用、箭头|  
|随机访问迭代器|可读写；多遍扫描；支持全部迭代器运算|相等性比较、关系运算、算术运算、递增、递减、解引用、箭头、下标|  

## 练习10.39
> list 上的迭代器属于哪类？vector呢？

`list`的迭代器可递增可递减，不支持算术运算，因此属于**双向迭代器**  
`vector`的迭代器支持下标与算术运算，因此属于**随机访问迭代器**  

## 练习10.40
> 你认为 copy 要求哪类迭代器？reverse 和 unique 呢？

* copy 接受一个迭代器范围，读取这个范围内的元素，并输出到第三个迭代器表示的输出序列中，因此要求前两个参数至少是输入迭代器，第三个参数至少是输出迭代器。  
* reverse 接受一个迭代器范围，将范围内的元素颠倒，它需要递减运算来逆序读取元素，因此要求两个参数至少是双向迭代器。  
* unique 接受一个迭代器范围，将范围内相邻的重复元素消除，为了判断相邻元素是否相同需要读取元素，而为了消除重复元素它也需要写入元素，因此要求两个参数至少是前向迭代器。  

## 练习10.41
> 仅根据算法和参数的名字，描述下面每个标准库算法执行什么操作：
```cpp
replace(beg, end, old_val, new_val);
replace_if(beg, end, pred, new_val);
replace_copy(beg, end, dest, old_val, new_val);
replace_copy_if(beg, end, dest, pred, new_val);
```
`replace`将`beg`和`end`范围内值为`old_val`的元素替换为`new_val`。  
`replace_if`将`beg`和`end`范围内令谓词`pred`为`true`的元素替换为`new_val`。  
`replace_copy`将`beg`和`end`范围内的元素拷贝到`dest`开始的目的序列，同时将其中值为`old_val`的元素替换为`new_val`。    
`replace_copy_if`将`beg`和`end`范围内的元素拷贝到`dest`开始的目的序列，同时将其中令谓词`pred`为`true`的元素替换为`new_val`。  

## [练习10.42](ex10_42.cpp)
> 使用 list 代替 vector 重新实现 10.2.3 节（第 343 页）中的去除重复单词的程序。
