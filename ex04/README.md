## 练习4.1
> 表达式 5 + 10 * 20 / 2 的求值结果是多少？

`105`

## 练习4.2
> 根据 4.12 节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。  
> (a) *vec.begin()  
> (b) *vec.begin() + 1  

(a) `*(vec.begin())`  
(b) `(*(vec.begin())) + 1`  

## 练习4.3
> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

可以接受，引起潜在缺陷的原因是表达式指向并修改了同一个对象，这种情形很少见，如果实在需要完全可以在表达式之前或之后去明确定义或修改对象，而不必要放在一条表达式中。  
代码编写者只要坚持运算对象彼此无关，不改变同一对象的状态也不执行IO任务，那么函数的调用顺序就是不受限制的，编译器可以根据需要进行优化提高效率。  

## [练习4.4](ex04_04.cpp)
> 在下面的表达式中添加括号，说明其求值的过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。  
`12 / 3 * 4 + 5 * 15 + 24 % 4 / 2`

1. `(((12 / 3) * 4) + (5 * 15)) + ((24 % 4) / 2)`  
2. `(16 + 75) + 0`  
3. `91`  

## 练习4.5
> 写出下列表达式的求值结果。  
> (a) -30 * 3 + 21 / 5  
> (b) -30 + 3 * 21 / 5  
> (c) 30 / 3 * 21 % 5  
> (d) -30 / 3 * 21 % 4  

(a) `((-30) * 3) + (21 / 5) = -86`  
(b) `(-30) + ((3 * 21) / 5) = -18`  
(c) `((30 / 3) * 21) % 5 = 0`  
(d) `(((-30) / 3) * 21) % 4 = -2`  

## 练习4.6
> 写出一条表达式用于确定一个整数是奇数还是偶数。

`num % 2`，当结果为`1`时是奇数，当结果为`0`时是偶数。

## 练习4.7
> 溢出是何含义？写出三条将导致溢出的表达式。

溢出是指计算的结果超出了该类型所能表示的范围，进而产生了未定义的行为。  
```cpp
short s = 32767 + 1;
int i = 2147483647 + 1;
int j = 2019 * 2019 * 2019;
```
在`short`类型使用`16`位，`int`类型使用`32`位的机器上，上述表达式的结果分别为：  
`-32768`、`-2147483648`和`-359761733`。显然结果不符合预期。  

## 练习4.8
> 说明在逻辑与、逻辑或及相等性运算符中运算对象求值的顺序。

逻辑与、逻辑或先计算左侧运算对象的值，当且仅当左侧运算对象的值无法确定表达式的结果时，才会计算右侧运算对象的值，这叫做短路求值策略。  
逻辑与仅当左侧运算对象的值为真时才会计算右侧对象的值，逻辑或仅当左侧运算对象的值为假时才会计算右侧对象的值。  
相等性运算符会计算左右两个运算对象的值，但没有规定它们的求值顺序。  


## 练习4.9
> 解释在下面的 if 语句中条件部分的判断过程。
```cpp
const char *cp = "Hello World";
if (cp && *cp)
```
条件部分采用了逻辑与运算符，仅当左侧运算对象的值`cp`为真时，才会对右侧运算对象`*cp`求值。  
`cp && *cp`的含义是，先判断指针是否是空指针，当指针不是空指针时，才对其解引用得到`char`类型字符，当该字符不是空字符`\0`时执行`if`代码块内的语句。  
由于指针`cp`指向了字符串的首字符`H`，因此满足`if`条件部分。  


## [练习4.10](ex04_10.cpp)
> 为 while 循环写一个条件，使其从标准输入中读取整数，遇到 42 时停止。

## 练习4.11
> 书写一条表达式用于测试 4 个值a、b、c、d的关系，确保 a 大于 b、b 大于 c、c 大于 d。

`a > b && b > c && c > d`

## 练习4.12
> 假设 i、j 和 k 是三个整数，说明表达式 i != j < k 的含义。

根据运算符优先级，表达式等价于`i != (j < k)`。  
首先`j < k`求值得到布尔值`true`或`false`。  
接着在不等运算符中，由于`i`是一个整数，`j < k`的结果布尔值被转换为`0`或`1`。  
最终判断`i`是否不等于`0`或`1`。  

## 练习4.13
> 在下述语句中，当赋值完成后 i 和 d 的值分别是多少？
> int i; double d;  
> (a) d = i = 3.5;    (b) i = d = 3.5;  

(a)`i = 3, d = 3.0`  
(b)`i = 3, d = 3.5`  

## 练习4.14

> 执行下述 if 语句后将发生什么情况？
```cpp
if (42 = i)
if (i = 42)
```
第一行条件非法，因为赋值运算符要求左侧运算对象是一个可修改的左值，而字面值是右值。  
第二行条件合法，但可能与意图不符。它将`42`赋给变量`i`，同时返回变量`i`作为表达式的结果。由于`42`转化为布尔值`true`，因此不论`i`的值是多少`if`语句块中的语句都将执行。  

## 练习4.15
> 下面的赋值是非法的，为什么？应该如何修改？
```cpp
double dval; int ival; int *pi;
dval = ival = pi = 0;
```

赋值运算符采用右结合律，因此该赋值等价于`dval = (ival = (pi = 0))`。  
第二个赋值运算符将指针赋给了整型变量，所以是非法的。指针和算数类型不能混合赋值，需要分开：  
```cpp
double dval; int ival; int *pi;
dval = ival = 0;
pi = 0;
```

## 练习4.16
> 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？  
> (a) if (p = getPtr() != 0)  
> (b) if (i = 1024)  

(a) 根据运算符优先级，表达式`p = getPtr() != 0`等价于`p = (getPtr() != 0)`，它将`getPtr() != 0`的布尔值结果赋值给了`p`。程序的本意是将`getPtr()`的结果赋给`p`然后判断`p`是否为空指针。  
应修改为`if ((p = getPtr()) != 0)`。  
(b) 赋值运算符返回左侧运算对象的左值，表达式`i = 1024`的的结果是`1024`，转换为布尔值`true`，因此不论`i`的值是多少`if`语句块中的语句都将执行。程序的本意是判断`i`和`1024`是否相等。  
应修改为`if (i == 1024)`。  

## 练习4.17
> 说明前置递增运算符和后置递增运算符的区别。

前置递增运算符返回递增后的对象的左值，后置递增运算符返回递增前的对象的右值副本。  

## 练习4.18
> 如果 132 页那个输出 vector 对象元素的 while 循环使用前置递增运算符，将得到什么结果？

`*++pbeg`等价于`*(++pbeg)`，它对递增后的迭代器解引用。  
这导致第一个元素被跳过，不会被输出。  
同时若`vector`中所有值都非负，那么最后一次循环时将试图解引用尾后迭代器。

## 练习4.19
> 假设 ptr 的类型是指向 int 的指针、vec 的类型是vector< int >、ival 的类型是 int，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？  
> (a) ptr != 0 && *ptr++  
> (b) ival++ && ival  
> (c) vec[ival++] <= vec[ival]   

(a) 判断`ptr`是否是空指针，如果不是空指针，计算右侧表达式，即判断`ptr`所指对象是否为`0`，如果不为`0`则表达式结果为`true`，同时对`ptr`进行了递增。  
(b) 递增`ival`，判断`ival`递增前的值是否为`0`，若非`0`则计算右侧表达式，即判断递增后的`ival`是否为`0`，如果不为`0`则表达式结果为`true`。  
换言之当`ival`是`-1`或`0`时表达式为`false`，其他情况为`true`。  
(c) 表达式是不正确的，程序的意图是判断`vec`中下标为`ival`的对象是否小于等于它后一个对象，但是`<=`运算符的求值顺序是未定义的。  
如果先计算左侧，则等价于`vec[ival] <= vec[ival + 1]`，如果先计算右侧，则等价于`vec[ival] <= vec[ival]`。应改为前者。  

## 练习4.20

> 假设 iter 的类型是 vector< string >::iterator，说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？  
> (a) *iter++;   (b) (*iter)++;  (c) *iter.empty();  
> (d) iter->empty();   (e) ++*iter;  (f) iter++->empty();  

(a) 合法，递增迭代器，然后对递增前的迭代器副本解引用。  
(b) 不合法，解引用迭代器得到`string`对象，它没有递增运算符。  
(c) 不合法，表达式等价于`*(iter.empty())`，迭代器类型没有`empty()`成员。  
(d) 合法，表达式等价于`(*iter).empty()`，解引用得到`string`对象，然后调用它的`empty`函数。  
(e) 不合法，表达式等价于`++(*iter)`，解引用得到`string`对象，它没有递增运算符。  
(f) 合法，表达式等价于`(iter++)->empty()`，递增迭代器，但对递增前的迭代器进行解引用得到`string`对象，然后调用它的`empty`函数。  

## [练习4.21](ex04_21.cpp)
> 编写一段程序，使用条件运算符从 vector< int > 中找到哪些元素的值是奇数，然后将这些奇数值翻倍。  

## [练习4.22](ex04_22.cpp)
> 本节的示例程序将成绩划分成 high pass、pass 和 fail 三种，扩展该程序使其进一步将 60 分到 75 分之间的成绩设定为 low pass。要求程序包含两个版本：一个版本只使用条件运算符；另外一个版本使用 1 个或多个 if 语句。哪个版本的程序更容易理解呢？为什么？

使用`if`语句的版本更容易理解，因为条件运算符的嵌套条件过多，代码的可读性非常差。  


## 练习4.23
> 因为运算符的优先级问题，下面这条表达式无法通过编译。根据 4.12 节中的表（第 147 页）指出它的问题在哪里？应该如何修改？
```cpp
string s = "word";
string pl = s + s[s.size() - 1] == 's' ? "" : "s" ;
```
表达式等价于`((s + s[s.size() - 1]) == 's') ? "" : "s"`，相等运算符的左侧运算对象是`string`，右侧运算对象是`char`，无法进行比较。  
程序的本意是给不以`s`结尾的字符串末尾添加`s`，应修改为：  
```cpp
string s = "word";
string pl = s + (s[s.size() - 1] == 's' ? "" : "s") ;
```

## 练习4.24
> 本节的示例程序将成绩划分为 high pass、pass、和 fail 三种，它的依据是条件运算符满足右结合律。假如条件运算符满足的是左结合律，求值的过程将是怎样的？

左结合律时的表达式等价于  
`((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass"`  
左侧条件运算符的结果将是右侧条件运算符的条件。但该表达式无法编译通过，因为条件运算符要求两个结果表达式类型相同，或者能转换为某种公共类型。但二者一个是`const char*`指针类型，另一个是`bool`布尔值类型，无法转换。

## 练习4.25
> 如果一台机器上 int 占 32 位、char 占 8 位，用的是 Latin-1 字符集，其中字符'q' 的二进制形式是 01110001，那么表达式~'q' << 6的值是什么？

表达式等价于`(~'q') << 6`，首先`q`会被提升成`int`类型，得到    
`00000000 00000000 00000000 01110001`，接着取反得到  
`11111111 11111111 11111111 10001110`，最后向左移动`6`位，得到  
`11111111 11111111 11100011 10000000`即`-7296`。  

## 练习4.26
> 在本节关于测验成绩的例子中，如果使用 unsigned int 作为 quiz1 的类型会发生什么情况？

C++规定`unsigned int`类型最少为`16`位，在`unsigned int`类型少于`30`位的机器上会出现数据丢失，无法存放`30`个学生的成绩信息。  


## 练习4.27
> 下列表达式的结果是什么？ 
> unsigned long ul1 = 3, ul2 = 7;  
> (a) ul1 & ul2    (b) ul1 | ul2   
> (c) ul1 && ul2  (d) ul1 || ul2   

`ul1`的二进制表示为`00000000 00000000 00000000 00000011`，  
`ul2`的二进制表示为`00000000 00000000 00000000 00000111`。  
(a) `0011 & 0111 = 0011`，即十进制`3`。  
(b) `0011 | 0111 = 0111`，即十进制`7`。  
(c) `3 && 7 = true && true`结果为`true`。  
(d) `3 || 7 = true || true`结果为`true`。  

## [练习4.28](ex04_28.cpp)
> 编写一段程序，输出每一种内置类型所占空间的大小。

## 练习4.29
> 推断下面代码的输出结果并说明理由。实际运行这段程序，结果和你想象的一样吗？如果不一样，为什么？
```cpp
int x[10];   int *p = x;
cout << sizeof(x)/sizeof(*x) << endl;
cout << sizeof(p)/sizeof(*p) << endl;
```
第一行输出`10`，`sizeof(x)`得到整个数组的大小，`sizeof(*x)`得到数组元素`int`类型的大小，二者相除得到数组中的元素个数`10`。  
第二行的结果与机器上指针类型和`int`类型所占字节数有关，`sizeof(p)`得到指针本身所占空间大小，`sizeof(*p)`得到`int`类型所占大小。  

## 练习4.30
> 根据 4.12 节中的表（第 147页 ），在下述表达式的适当位置加上括号，使得加上括号之后的表达式的含义与原来的含义相同。  
> (a) sizeof x + y   (b) sizeof p->mem[i]  
> (c) sizeof a < b   (d) sizeof f()  

(a) `(sizeof x) + y`  
(b) `sizeof (p->mem[i])`  
(c) `(sizeof a) < b`  
(d) `sizeof (f())`  

## [练习4.31](ex04_31.cpp)
> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节的程序。

因为不需要使用递增前的值，前置版本避免了不必要的操作，而后置版本会拷贝递增前的值并返回，增加了额外开销。  
本节中的程序使用后置版本不需要额外改动。  

## 练习4.32
> 解释下面这个循环的含义。
```cpp
constexpr int size = 5;
int ia[size] = { 1, 2, 3, 4, 5 };
for (int *ptr = ia, ix = 0;
    ix != size && ptr != ia+size;
    ++ix, ++ptr) { /* ... */ }
```  

循环遍历数组`ia`，它同时用了指针和下标。  

## 练习4.33
> 根据 4.12 节中的表（第 147 页）说明下面这条表达式的含义。
```cpp
someValue ? ++x, ++y : --x, --y
```
表达式等价于`(someValue ? (++x, ++y) : (--x)), --y`。  
如果`someValue`为真，计算表达式`++x, ++y`，逗号运算符首先计算左侧运算对象`++x`，然后计算右侧对象`++y`，并返回右侧运算对象，最后丢弃该计算结果，计算表达式`--y`作为整个表达式的值 。 
如果`someValue`为假，则计算表达式`--x`并返回，最后丢弃该计算结果，计算表达式`--y`作为整个表达式的值。  

## 练习4.34
> 根据本节给出的变量定义，说明在下面的表达式中将发生什么样的类型转换：
> (a) if (fval)  (b) dval = fval + ival; (c) dval + ival * cval;  

(a) `float`将转换为`bool`  
(b) `ival`首先转换为`float`，相加的结果转换为`double`  
(c) `cval`首先被提升为`int`，然后相乘的结果被转换为`double`  

## 练习4.35
> 假设有如下的定义：
```cpp
char cval;   int ival;  unsigned int ui;
float fval;  double dval;
```
> 请回答在下面的表达式中发生了隐式类型转换吗？如果有，指出来。  
> (a) cval = 'a' + 3;   (b) fval = ui - ival * 1.0;  
> (c) dval = ui * fval;   (d) cval = ival + fval + dval;  

(a) `a`被提升为`int`类型，相加的结果被转换为`char`类型。  
(b) `ival`被转换为`double`类型，`ui`被转换为`double`类型，相减的结果被转换为`float`类型。  
(c) `ui`被转换为`float`类型，相乘的结果被转换为`double`类型。  
(d) `ival`被转换成`float`类型，相加的结果被转换成`double`类型，最终的结果被转换成`char`类型。  

## 练习4.36
> 假设 i 是 int 类型，d 是 double 类型，书写表达式 i*=d 使其执行整数类型的乘法而非浮点类型的乘法。

```cpp
i *= static_cast<int>(d);
```

## 练习4.37
> 用命名的强制类型转换改写下列旧式的转换语句。  
> int i; double d; const string *ps; char *pc; void *pv;  
> (a) pv = (void*)ps;   (b) i = int(*pc);  
> (c) pv = &d;   (d) pc = (char*)pv;  

(a) `pv = static_cast<void*>(const_cast<string *>(ps));`  
(b) `i = static_cast<int>(*pc);`  
(c) `pv = static_cast<void*>(&d);`  
(d) `pc = static_cast<char*>(pv);`  

## 练习4.38
> 说明下面这条表达式的含义。
```cpp
double slope = static_cast<double>(j/i);
```
将`j / i`的结果转换为`double`类型。  