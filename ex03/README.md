## [练习3.1](ex03_01)
> 使用恰当的 using 声明重做 1.4.1 节（第11页）和 2.6.2 节（第67页）的练习。

只需将练习中的`std::`删除，并在前面加上`using`声明。  

## [练习3.2](ex03_02)
> 编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词。

## 练习3.3 
> 请说明 string 类的输入运算符和 getline 函数分别是如何处理空白字符的。

string 类的输入运算符在读取时，会自动忽略字符串开头的空白，并从第一个非空白字符开始读取，直到遇见下一个空白为止。停止时的空白并不会被读取进来，它仍然在输入流中等待读取。  
getline 函数在读取时，会读取输入流中的所有内容，直到遇到换行符。停止时的换行符会被读取进来，但不会存入 string 对象中，它已经不在输入流中了。  
可通过以下代码测试：  
```cpp
string word;
cin >> word;
cout << "[" << word << "]";
getline(cin, word);
cout << "[" << word << "]";
getline(cin, word);
cout << "[" << word << "]";
```
输入`aa bb cc换行dd ee换行`，会输出`[aa][ bb cc][dd ee]`

## [练习3.4](ex03_04)
> 编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等，输出比较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。

## [练习3.5](ex03_05)
> 编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。

## [练习3.6](ex03_06.cpp) 
> 编写一段程序，使用范围 for 语句将字符串内所有字符用 X 代替。

## [练习3.7](ex03_07.cpp)
> 就上一题完成的程序而言，如果将循环控制变量的类型设为 char 将发生什么？先估计一下结果，然后实际编程进行验证。

字符串不会被改变。  

## [练习3.8](ex03_08)
> 分别用 while 循环和传统的 for 循环重写第一题的程序，你觉得哪种形式更好呢？为什么？

与while循环和传统for循环相比，范围for循环更加简洁直观。  

## 练习3.9
> 下面的程序有何作用？它合法吗？如果不合法？为什么？
```cpp
string s;
cout << s[0] << endl;
```

程序试图输出字符串s的首字符。  
尽管部分编译器不会报错，但它不合法，因为使用下标访问空字符串会引发不可预知的行为。  

## [练习3.10](ex03_10.cpp)
> 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。

## 练习3.11
> 下面的范围 for 语句合法吗？如果合法，c 的类型是什么？
```cpp
const string s = "Keep out!";
for(auto &c : s){ /* ... */ }
```
`c`是对常量字符的引用`const char &`类型。  
若在循环体中试图修改`c`的值，则不合法。其他情况是合法的。  

## 练习3.12
> 下列 vector 对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。
```cpp
vector<vector<int>> ivec;
vector<string> svec = ivec;
vector<string> svec(10, "null");
```
第一行的定义是正确的，它定义了一个元素类型为`vector<int>`的空`vector`。  
第二行的定义是不正确的，`vector`的拷贝初始化要求两个`vector`的元素类型必须相同。  
第三行的定义是正确的，它定义了一个元素类型为`string`的`vector`，含有`10`个字符串`null`。  

## 练习3.13
> 下列的 vector 对象各包含多少个元素？这些元素的值分别是多少？
```cpp
vector<int> v1;
vector<int> v2(10);
vector<int> v3(10, 42);
vector<int> v4{ 10 };
vector<int> v5{ 10, 42 };
vector<string> v6{ 10 };
vector<string> v7{ 10, "hi" };
```
`v1`有`0`个元素。  
`v2`有`10`个元素，值都为`0`。  
`v3`有`10`个元素，值都为`42`。  
`v4`有`1`个元素，值为`10`。  
`v5`有`2`个元素，值为`10`和`42`。  
`v6`有`10`个元素，值都为空串。
`v7`有`10`个元素，值都为`hi`。

## [练习3.14](ex03_14.cpp)
> 编写一段程序，用 cin 读入一组整数并把它们存入一个 vector 对象。

## [练习3.15](ex03_15.cpp)
> 改写上题程序，不过这次读入的是字符串。

## [练习3.16](ex03_16.cpp)
> 编写一段程序，把练习 3.13 中 vector 对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回过头重新学习 3.3.1 节（第87页）直到弄明白错在何处为止。

## [练习3.17](ex03_17.cpp)
> 从 cin 读入一组词并把它们存入一个 vector 对象，然后设法把所有词都改写为大写形式。输出改变后的结果，每个词占一行。

## 练习3.18
> 下面的程序合法吗？如果不合法，你准备如何修改？
```cpp
vector<int> ivec;
ivec[0] = 42;
```
不合法，程序试图访问不存在的下标，会导致未定义行为。假设程序的目的是添加元素`42`，则应改为：  
```cpp
vector<int> ivec;
ivec.push_back(42);
```

## 练习3.19
> 如果想定义一个含有 10 个元素的 vector 对象，所有元素的值都是 42，请列举三种不同的实现方法。哪种方法更好呢？为什么？
```cpp
vector<int> ivec1(10, 42); // 直接初始化，指定元素个数和重复的值
vector<int> ivec2{ 42,42,42,42,42,42,42,42,42,42 }; // 列表初始化
vector<int> ivec3; // 定义空的vector，push_back十次。
for (int i = 0; i < 10; ++i) {
	ivec3.push_back(42);
}
vector<int> ivec4(10); // 定义10个元素默认初始化的vector，范围for修改值
for (auto &v : ivec4) {
	v = 42;
}
```
第一种直接初始化的方法最好，因为最简洁。  

## [练习3.20](ex03_20.cpp)
> 读入一组整数并把它们存入一个 vector 对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第 1 个和最后 1 个元素的和，接着输出第 2 个和倒数第 2 个元素的和，以此类推。

## [练习3.21](ex03_21.cpp)
> 请使用迭代器重做 3.3.3 节（第94页）的第一个练习。

## [练习3.22](ex03_22.cpp)
> 修改之前那个输出 text 第一段的程序，首先把 text 的第一段全都改成大写形式，然后再输出它。

## [练习3.23](ex03_23.cpp)
> 编写一段程序，创建一个含有 10 个整数的 vector 对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出 vector 对象的内容，检验程序是否正确。

## [练习3.24](ex03_24.cpp)
> 请使用迭代器重做 3.3.3 节（第94页）的最后一个练习。

## [练习3.25](ex03_25.cpp)
> 3.3.3 节（第93页）划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序并实现完全相同的功能。

## 练习3.26
> 在 100 页的二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2，而非 mid = (beg + end) / 2 ; ？

因为C++没有定义两个迭代器的加法运算，这个操作也是没有意义的，所以`beg + end`不合法。  
`(end - beg) / 2`表示总长度的一半，`beg + (end - beg) / 2`表示将迭代器从`beg`的位置向右移动总长度的一半，从而定位到中间的位置。  
另外，即便`beg`和`end`是整型索引，采用前者也比后者要好，因为如果`end`是一个极大的数字，它接近该整型类型所能存储的最大值，此时`beg + end`将有可能导致溢出，计算出的`mid`也将是错误的。  

## 练习3.27
> 假设 txt_size 是一个无参数的函数，它的返回值是 int。请回答下列哪个定义是非法的，为什么？  
> unsigned buf_size = 1024;  
> (a) int ia[buf_size];  
> (b) int ia[4 * 7 - 14];  
> (c) int ia[txt_size()];  
> (d) char st[11] = "fundamental";  

(a) 是非法的，数组的维度必须是一个常量表达式。  
(b) 是合法的。  `4 * 7 - 14`是一个常量表达式。
(c) 是非法的，因为`txt_size()`函数不是`constexpr`函数。  
(d) 是非法的，因为用字符串字面值初始化的数组，结尾会有一个空字符，因此数组的长度应该至少为`12`才能容纳该字符串。   


## 练习3.28
> 下列数组中元素的值是什么？
```cpp
string sa[10];
int ia[10];
int main() {
	string sa2[10];
	int ia2[10];
}
```
`sa`和`sa2`中的元素值都是空串。  
`ia`中的元素值为0，`ia2`中的元素值是未定义的。  
数组的元素都被默认初始化，和定义变量时一样，定义数组的位置与类型决定了元素是否有默认值。  

## 练习3.29
> 相比于vector 来说，数组有哪些缺点，请列举一些。

数组的大小是固定不可修改的，不能随意增加元素，缺少灵活性。  
无法对数组进行拷贝和赋值。  
数组只能的显式初始化办法只有列表初始化一种。  

## 练习3.30
> 指出下面代码中的索引错误。
```cpp
constexpr size_t array_size = 10;
int ia[array_size];
for (size_t ix = 1; ix <= array_size; ++ix)
	ia[ix] = ix;
```
当`ix`等于`10`时循环条件仍满足，此时`ia[ix]`导致了索引错误。


## [练习3.31](ex03_31.cpp)
> 编写一段程序，定义一个含有10个int 的数组，令每个元素的值就是其下标值。

## [练习3.32](ex03_32)
> 将上一题刚刚创建的数组拷贝给另外一个数组。利用 vector 重写程序，实现类似的功能。

## 练习3.33
> 对于 104 页的程序来说，如果不初始化 scores 将会发生什么？

在统计各分数段人数时，初始的人数应该是`0`，由于`scores`定义在`main`函数内部，如果不初始化，数组内的元素将含有未定义的值，这样初始人数就会是难以预料的。  

## 练习3.34
> 假定 p1 和 p2 指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？
```cpp
p1 += p2 - p1;
```
`p2 - p1`得到两个指针之间的距离，`p1`加上这个距离得到`p2`，并赋值给`p1`。即令`p1`指向原来`p2`所指的对象。  
当`p1`或`p2`是`void *`指针时该程序非法，尽管`void *`指针可以指向数组中的元素，但它们不能进行数组运算。  

## [练习3.35](ex03_35.cpp)
> 编写一段程序，利用指针将数组中的元素置为0。

## [练习3.36](ex03_36)
> 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个 vector 对象是否相等。

## 练习3.37
> 下面的程序是何含义，程序的输出结果是什么？
```cpp
const char ca[] = { 'h', 'e', 'l', 'l', 'o' };
const char *cp = ca;
while (*cp) {
    cout << *cp << endl;
    ++cp;
}
```
程序的目的是将字符数组`ca`打印出来，但是由于数组中没有空字符，循环条件`*cp`永远满足，程序将沿着`ca`在内存中的位置不断向前查找并打印，直至遇到一个空字符。  
输出结果将为`hello`后面跟一串随机字符。  


## 练习3.38
> 在本节中我们提到，将两个指针相加不但是非法的，而且也没什么意义。请问为什么两个指针相加没什么意义？

指针的值是对象在内存中的地址，两个地址相加的结果没有一个有逻辑的含义，因此指针相加是非法且没有意义的。与之相反，两个地址相减的结果存在一个有逻辑的含义，即两个地址之间的距离，因此指针相减是合法的。  

## [练习3.39](ex03_39)
> 编写一段程序，比较两个string 对象。再编写一段程序，比较两个 C 风格字符串的内容。

## [练习3.40](ex03_40.cpp)
> 编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用 strcpy 和 strcat 把前两个数组的内容拷贝到第三个数组中。

## [练习3.41](ex03_41.cpp)
> 编写一段程序，用整型数组初始化一个 vector 对象。

## [练习3.42](ex3_42.cpp)
> 编写一段程序，将含有整数元素的 vector 对象拷贝给一个整型数组。

## [练习3.43](ex03_43.cpp)
> 编写3个不同版本的程序，令其均能输出 ia 的元素。版本 1 使用范围 for 语句管理迭代过程；版本 2 和版本 3 都使用普通的 for 语句，其中版本 2 要求用下标运算符，版本 3 要求用指针。此外，在所有 3 个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto 关键字或 decltype 关键字。

## [练习3.44](ex03_44.cpp)
> 改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。

## [练习3.45](ex03_45.cpp)
> 再一次改写程序，这次使用 auto 关键字。
